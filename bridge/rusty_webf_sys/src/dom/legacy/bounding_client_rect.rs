// Generated by WebF TSDL, don't edit this file directly.
// Generate command: node scripts/generate_binding_code.js
/*
* Copyright (C) 2022-present The WebF authors. All rights reserved.
*/
use std::ffi::*;
use crate::*;
#[repr(C)]
enum BoundingClientRectType {
  BoundingClientRect = 0,
}
#[repr(C)]
pub struct BoundingClientRectRustMethods {
  pub version: c_double,
  pub x: extern "C" fn(ptr: *const OpaquePtr) -> c_double,
  pub y: extern "C" fn(ptr: *const OpaquePtr) -> c_double,
  pub width: extern "C" fn(ptr: *const OpaquePtr) -> c_double,
  pub height: extern "C" fn(ptr: *const OpaquePtr) -> c_double,
  pub top: extern "C" fn(ptr: *const OpaquePtr) -> c_double,
  pub right: extern "C" fn(ptr: *const OpaquePtr) -> c_double,
  pub bottom: extern "C" fn(ptr: *const OpaquePtr) -> c_double,
  pub left: extern "C" fn(ptr: *const OpaquePtr) -> c_double,
  pub release: extern "C" fn(ptr: *const OpaquePtr) -> c_void,
  pub dynamic_to: extern "C" fn(ptr: *const OpaquePtr, type_: BoundingClientRectType) -> RustValue<c_void>,
}
pub struct BoundingClientRect {
  pub ptr: *const OpaquePtr,
  context: *const ExecutingContext,
  method_pointer: *const BoundingClientRectRustMethods,
  status: *const RustValueStatus
}
impl BoundingClientRect {
  pub fn initialize(ptr: *const OpaquePtr, context: *const ExecutingContext, method_pointer: *const BoundingClientRectRustMethods, status: *const RustValueStatus) -> BoundingClientRect {
    BoundingClientRect {
      ptr,
      context,
      method_pointer,
      status
    }
  }
  pub fn ptr(&self) -> *const OpaquePtr {
    self.ptr
  }
  pub fn context<'a>(&self) -> &'a ExecutingContext {
    assert!(!self.context.is_null(), "Context PTR must not be null");
    unsafe { &*self.context }
  }
  pub fn x(&self) -> f64 {
    let value = unsafe {
      ((*self.method_pointer).x)(self.ptr())
    };
    value
  }
  pub fn y(&self) -> f64 {
    let value = unsafe {
      ((*self.method_pointer).y)(self.ptr())
    };
    value
  }
  pub fn width(&self) -> f64 {
    let value = unsafe {
      ((*self.method_pointer).width)(self.ptr())
    };
    value
  }
  pub fn height(&self) -> f64 {
    let value = unsafe {
      ((*self.method_pointer).height)(self.ptr())
    };
    value
  }
  pub fn top(&self) -> f64 {
    let value = unsafe {
      ((*self.method_pointer).top)(self.ptr())
    };
    value
  }
  pub fn right(&self) -> f64 {
    let value = unsafe {
      ((*self.method_pointer).right)(self.ptr())
    };
    value
  }
  pub fn bottom(&self) -> f64 {
    let value = unsafe {
      ((*self.method_pointer).bottom)(self.ptr())
    };
    value
  }
  pub fn left(&self) -> f64 {
    let value = unsafe {
      ((*self.method_pointer).left)(self.ptr())
    };
    value
  }
}
impl Drop for BoundingClientRect {
  fn drop(&mut self) {
    unsafe {
      ((*self.method_pointer).release)(self.ptr());
    }
  }
}
pub trait BoundingClientRectMethods {
  fn x(&self) -> f64;
  fn y(&self) -> f64;
  fn width(&self) -> f64;
  fn height(&self) -> f64;
  fn top(&self) -> f64;
  fn right(&self) -> f64;
  fn bottom(&self) -> f64;
  fn left(&self) -> f64;
  fn as_bounding_client_rect(&self) -> &BoundingClientRect;
}
impl BoundingClientRectMethods for BoundingClientRect {
  fn x(&self) -> f64 {
    self.x()
  }
  fn y(&self) -> f64 {
    self.y()
  }
  fn width(&self) -> f64 {
    self.width()
  }
  fn height(&self) -> f64 {
    self.height()
  }
  fn top(&self) -> f64 {
    self.top()
  }
  fn right(&self) -> f64 {
    self.right()
  }
  fn bottom(&self) -> f64 {
    self.bottom()
  }
  fn left(&self) -> f64 {
    self.left()
  }
  fn as_bounding_client_rect(&self) -> &BoundingClientRect {
    self
  }
}
