// Generated by WebF TSDL, don't edit this file directly.
// Generate command: node scripts/generate_binding_code.js
/*
* Copyright (C) 2022-present The WebF authors. All rights reserved.
*/
use std::ffi::*;
use crate::*;
#[repr(C)]
enum TouchType {
  Touch = 0,
}
#[repr(C)]
pub struct TouchRustMethods {
  pub version: c_double,
  pub altitude_angle: extern "C" fn(ptr: *const OpaquePtr) -> c_double,
  pub azimuth_angle: extern "C" fn(ptr: *const OpaquePtr) -> c_double,
  pub client_x: extern "C" fn(ptr: *const OpaquePtr) -> c_double,
  pub client_y: extern "C" fn(ptr: *const OpaquePtr) -> c_double,
  pub force: extern "C" fn(ptr: *const OpaquePtr) -> c_double,
  pub identifier: extern "C" fn(ptr: *const OpaquePtr) -> c_double,
  pub page_x: extern "C" fn(ptr: *const OpaquePtr) -> c_double,
  pub page_y: extern "C" fn(ptr: *const OpaquePtr) -> c_double,
  pub radius_x: extern "C" fn(ptr: *const OpaquePtr) -> c_double,
  pub radius_y: extern "C" fn(ptr: *const OpaquePtr) -> c_double,
  pub rotation_angle: extern "C" fn(ptr: *const OpaquePtr) -> c_double,
  pub screen_x: extern "C" fn(ptr: *const OpaquePtr) -> c_double,
  pub screen_y: extern "C" fn(ptr: *const OpaquePtr) -> c_double,
  pub target: extern "C" fn(ptr: *const OpaquePtr) -> RustValue<EventTargetRustMethods>,
  pub release: extern "C" fn(ptr: *const OpaquePtr) -> c_void,
  pub dynamic_to: extern "C" fn(ptr: *const OpaquePtr, type_: TouchType) -> RustValue<c_void>,
}
pub struct Touch {
  pub ptr: *const OpaquePtr,
  context: *const ExecutingContext,
  method_pointer: *const TouchRustMethods,
  status: *const RustValueStatus
}
impl Touch {
  pub fn initialize(ptr: *const OpaquePtr, context: *const ExecutingContext, method_pointer: *const TouchRustMethods, status: *const RustValueStatus) -> Touch {
    Touch {
      ptr,
      context,
      method_pointer,
      status
    }
  }
  pub fn ptr(&self) -> *const OpaquePtr {
    self.ptr
  }
  pub fn context<'a>(&self) -> &'a ExecutingContext {
    assert!(!self.context.is_null(), "Context PTR must not be null");
    unsafe { &*self.context }
  }
  pub fn altitude_angle(&self) -> f64 {
    let value = unsafe {
      ((*self.method_pointer).altitude_angle)(self.ptr())
    };
    value
  }
  pub fn azimuth_angle(&self) -> f64 {
    let value = unsafe {
      ((*self.method_pointer).azimuth_angle)(self.ptr())
    };
    value
  }
  pub fn client_x(&self) -> f64 {
    let value = unsafe {
      ((*self.method_pointer).client_x)(self.ptr())
    };
    value
  }
  pub fn client_y(&self) -> f64 {
    let value = unsafe {
      ((*self.method_pointer).client_y)(self.ptr())
    };
    value
  }
  pub fn force(&self) -> f64 {
    let value = unsafe {
      ((*self.method_pointer).force)(self.ptr())
    };
    value
  }
  pub fn identifier(&self) -> f64 {
    let value = unsafe {
      ((*self.method_pointer).identifier)(self.ptr())
    };
    value
  }
  pub fn page_x(&self) -> f64 {
    let value = unsafe {
      ((*self.method_pointer).page_x)(self.ptr())
    };
    value
  }
  pub fn page_y(&self) -> f64 {
    let value = unsafe {
      ((*self.method_pointer).page_y)(self.ptr())
    };
    value
  }
  pub fn radius_x(&self) -> f64 {
    let value = unsafe {
      ((*self.method_pointer).radius_x)(self.ptr())
    };
    value
  }
  pub fn radius_y(&self) -> f64 {
    let value = unsafe {
      ((*self.method_pointer).radius_y)(self.ptr())
    };
    value
  }
  pub fn rotation_angle(&self) -> f64 {
    let value = unsafe {
      ((*self.method_pointer).rotation_angle)(self.ptr())
    };
    value
  }
  pub fn screen_x(&self) -> f64 {
    let value = unsafe {
      ((*self.method_pointer).screen_x)(self.ptr())
    };
    value
  }
  pub fn screen_y(&self) -> f64 {
    let value = unsafe {
      ((*self.method_pointer).screen_y)(self.ptr())
    };
    value
  }
  pub fn target(&self) -> EventTarget {
    let value = unsafe {
      ((*self.method_pointer).target)(self.ptr())
    };
    EventTarget::initialize(value.value, self.context(), value.method_pointer, value.status)
  }
}
impl Drop for Touch {
  fn drop(&mut self) {
    unsafe {
      ((*self.method_pointer).release)(self.ptr());
    }
  }
}
pub trait TouchMethods {
  fn altitude_angle(&self) -> f64;
  fn azimuth_angle(&self) -> f64;
  fn client_x(&self) -> f64;
  fn client_y(&self) -> f64;
  fn force(&self) -> f64;
  fn identifier(&self) -> f64;
  fn page_x(&self) -> f64;
  fn page_y(&self) -> f64;
  fn radius_x(&self) -> f64;
  fn radius_y(&self) -> f64;
  fn rotation_angle(&self) -> f64;
  fn screen_x(&self) -> f64;
  fn screen_y(&self) -> f64;
  fn target(&self) -> EventTarget;
  fn as_touch(&self) -> &Touch;
}
impl TouchMethods for Touch {
  fn altitude_angle(&self) -> f64 {
    self.altitude_angle()
  }
  fn azimuth_angle(&self) -> f64 {
    self.azimuth_angle()
  }
  fn client_x(&self) -> f64 {
    self.client_x()
  }
  fn client_y(&self) -> f64 {
    self.client_y()
  }
  fn force(&self) -> f64 {
    self.force()
  }
  fn identifier(&self) -> f64 {
    self.identifier()
  }
  fn page_x(&self) -> f64 {
    self.page_x()
  }
  fn page_y(&self) -> f64 {
    self.page_y()
  }
  fn radius_x(&self) -> f64 {
    self.radius_x()
  }
  fn radius_y(&self) -> f64 {
    self.radius_y()
  }
  fn rotation_angle(&self) -> f64 {
    self.rotation_angle()
  }
  fn screen_x(&self) -> f64 {
    self.screen_x()
  }
  fn screen_y(&self) -> f64 {
    self.screen_y()
  }
  fn target(&self) -> EventTarget {
    self.target()
  }
  fn as_touch(&self) -> &Touch {
    self
  }
}
impl ExecutingContext {
}
